= `tjr_btree`: a COW B-tree library
:toc: right
:icons: font
:nofooter:

== Description

`tjr_btree` is a B-tree library written in OCaml. The examples include
a simple on-disk key-value store.

== Example

This is taken from link:src/m_main/simple_example.ml[]. 

----
(** A simple example of a kv store. *)

open Small_string.O
(* SS is now an alias for Small_string *)

open Ss_ss_map_on_fd

(* filename *)
let fn = Default.default_filename

(* construct keys and values from an int *)
let k x = "k"^(string_of_int x) |> SS.of_string
let v x = "v"^(string_of_int x) |> SS.of_string

(* create and init store, write some values, and close *)
let do_write () = (
  print_endline "Writing...";
  (* create and initialize *)
  let s = ref (from_file ~fn ~create:true ~init:true) in
  (* get map operations *)
  let map_ops = imperative_map_ops s in
  (* write values *)
  for x=1 to 1000 do
    (* TODO this would be much faster if we used insert_many *)
    map_ops.insert (k x) (v x);
  done;
  (* close *)
  close !s
)

(* open store, delete some values, and close *)
let do_delete () = (
  print_endline "Deleting...";
  let s = ref (from_file ~fn ~create:false ~init:false) in
  let map_ops = imperative_map_ops s in
  for x=100 to 200 do
    map_ops.delete (k x);
  done;
  close !s
)

(* open store and check whether various keys and values are correct *)
let do_check () = (
  print_endline "Checking...";
  let s = ref (from_file ~fn ~create:false ~init:false) in
  let map_ops = imperative_map_ops s in
  assert(map_ops.find (SS.of_string("k100")) = None);
  assert(map_ops.find (SS.of_string("k1000")) = Some(SS.of_string("v1000")));
  close !s
)

(* actually execute the above *)
let _ = (
  do_write();
  do_delete();
  do_check()
)
----


== Introduction

The core code is written in Isabelle/HOL and exported to OCaml
(although it could easily be implemented in any language because the
routines are very "concrete"). Further routines are written in OCaml.

The B-tree is a simple COW B-tree. All sync-ed states are persistent
on disk (imagine that blocks are written once and then never mutated),
so operations such as "snapshot" are almost trivial.

The B-tree supports the usual operations: `find`, `insert`, `delete`.
In addition, there is an `insert_many` operation for inserting
multiple key-value pairs at once. This operation is more efficient
than repeatedly inserting. It is typically used when higher-level
operations are cached and then flushed all at once.

The routines are fully parameterized (e.g., by key and value type, key
order, store type etc). It is easy to have many B-trees using the same
store, even operating concurrently (although individual B-trees must
be updated sequentially at the moment).

The core is implemented in small-step operational style, with each
disk access corresponding to a separate step. Thus, it should be
feasible to introduce very fine-grained concurrency by interleaving
individual steps of each operation (where multiple operations execute
on different B-trees).

== Relation to ImpFS

ImpFS is a project to build an advanced high-performance filesystem.
`tjr_btree` is the core library used by ImpFS.

== Installation

Type `make && make install` to make the library and install it using
`ocamlfind`. You need various libraries from opam (see `bash_env.sh`
for details).

To build with nix, type `cd .nix/tjr_btree; nix-build`. The result is in `./result`.


== Documentation

Please read the
https://tomjridge.github.io/tjr_btree/Tjr_btree_doc.html[overview]
and the 
https://tomjridge.github.io/tjr_btree/[ocamldoc]

