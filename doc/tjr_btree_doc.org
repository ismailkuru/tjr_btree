* Guide to the code

Note: copy all the ml files to this directory, so that org-style linking works
correctly, then read this file in org-mode in emacs (or just plain text).

** Stores

A B-tree implements a map on top of block-based storage such as a
disk. We distinguish:

- a store
- a disk

A store is like a disk, but it potentially tracks alloc/free
information for blocks.

A disk is just an array of blocks.

The main interfaces, including those for disk and store, are in file:btree_api.ml

The store interface is described in file:btree_api.ml::store_ops which
links to file:store_ops.ml

To understand this interface, we need to introduce the following:

- Keys, represented by type variable ~k~
- Values, by type var ~v~
- Page/block references, ~r~
- Global state, ~t~

The interface also mentions frames. Disks store raw blocks, and a
block is an array of bytes. At a higher level, this corresponds to
some node in a B-tree. These nodes are called frames. The conversion
from frames to raw bytes (and back again) happens below the store
interface, and typically uses some form of marshalling. We discuss
this below, when describing how to convert a disk (which works with
blocks) to a store (which works with frames).

Finally, the code makes heavy use of a state-passing monad
file:simple_monad.ml which also handles errors. The type ~('a,'t)m~ is
a function from an initial state to a final state, with a result of
type ~'a~ (or possibly an error). See file:simple_monad.ml::type

If we now look at the store interface, we see 3 operations:

- file:store_ops.ml::store_alloc to allocate a new page holding a
  given frame; the page reference is returned
- file:store_ops.ml::store_free to free some page references (it is
  common to free many references in a single step rather than free
  references individually)
- file:store_ops.ml::store_read to read a page, given a page reference


** From stores to maps

The store operations are combined in a record. The reason for this is
that we want to implement a function ~make_map~ which takes some store
operations and uses the B-tree datastructure to produce a map.

The map interface is described in file:btree_api.ml::map_ops These are
the usual find, insert, and delete operations. In addition, it is
often useful to extract all the (key,value) bindings in a map. This is
implemented using a "leaf stream" (a stream of leaves in the B-tree),
see file:btree_api.ml::ls_ops

To convert a store to a map we use the function
[[file:store_to_map.ml::make_map_ops ps]]

This function has two parameters, ~ps~ (which in turn includes
parameters describing e.g. the order on the key type) and
~page_ref_ops~. To understand ~page_ref_ops~ we turn to the type
~pre_map_ops~ in file:pre_map_ops.ml::pre_map_ops A pre-map is like a
map, but the reference to the root of the B-tree is made explicit. For
example, the delete command takes a key AND a block/page reference to
the root of a B-tree in the store.

#+BEGIN_SRC
  delete: 'k -> 'r -> ('r,'t) m;
#+END_SRC

It then takes a state (of type ~'t~, captured in the monad ~m~) and returns
an updated state AND a new pointer to the root of a new B-tree (with
the key deleted).

For COW B-trees, a pre-map is the natural interface. To get to the
desired map interface we need to add some extra functionality. To this
end, we assume that the global state contains a (functionally
updateable in state-passing style) reference to the root of the
relevant B-tree. We need to be able to read and write this
reference. This is the purpose of the type file:store_to_map.ml::page_ref_ops

*** An example to explain ~page_ref_ops~

If this sounds complicated, an example may help. In file:test_mem_map.ml
we define the global state as [[file:test_mem_map.ml::type t]]  Ignoring
the tree component, the global state consists of a store (an in-memory
store in this example) and a page ref r (pointing to the root of the
B-tree). The implementation of ~page_ref_ops~ is then
file:test_mem_map.ml::pr_ops, which we reproduce here:

#+BEGIN_SRC
let pr_ops = Store_to_map.{
    get_page_ref=(fun () -> fun t -> (t,Ok t.r));
    set_page_ref=(fun r -> fun t -> ({t with r},Ok ()))
  }
#+END_SRC

Given that we are using a state-passing style, this is as simple as it
could be.

Thus, given a store we can use the B-tree to produce a pre-map, and if
we then track the pointer to the root of the B-tree in the global
state using ~page_ref_ops~ we can obtain a fully-fledged map.


** Example: an in-memory map from int to int

TODO put this in examples

** From disk to store

Stores are a reasonable cut point, but in the real world we must work
with raw disks which typically have no notion of alloc and free for
blocks. The disk interface is described in file:btree_api.ml::disk_ops

A simple strategy to implement a store from a disk is given in
file:disk_to_store.ml ; essentially we maintain a free counter, and
increase it every time we allocate a block/page. 

** Example: an on-disk map from int to int


