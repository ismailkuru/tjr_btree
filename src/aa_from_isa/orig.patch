--- orig.ml	2017-05-25 11:38:08.770537170 +0100
+++ patched.ml	2017-06-02 16:14:12.791304465 +0100
@@ -1,3 +1,7 @@
+(** This file is exported from Isabelle, and lightly patched (eg to
+   include this comment!). The OCaml interfaces wrap this basic
+   functionality. *)
+
 module Fun : sig
   val id : 'a -> 'a
   val comp : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
@@ -278,9 +282,14 @@ let rec is_none = function Some x -> fal
 
 end;; (*struct Option*)
 
+module Res = struct
+  include Pervasives
+  type 'a res = ('a,string) result
+end
+
 module Util : sig
+  include module type of Res
   type error = String_error of string
-  type 'a res = Ok of 'a | Error of error
   val rev_apply : 'a -> ('a -> 'b) -> 'b
   val unzip : ('a * 'b) list -> 'a list * 'b list
   val from_to : Arith.nat -> Arith.nat -> Arith.nat list
@@ -299,7 +308,7 @@ end = struct
 
 type error = String_error of string;;
 
-type 'a res = Ok of 'a | Error of error;;
+include Res
 
 let rec rev_apply x f = f x;;
 
@@ -311,7 +320,7 @@ let rec from_to x y = List.upt x (Arith.
 
 let rec is_None x = Option.is_none x;;
 
-let rec failwitha x = rev_apply "FIXME patch" (fun _ -> failwith "undefined");;
+let rec failwitha x = failwith x
 
 let rec assert_true b = (if b then b else failwitha "assert_true");;
 
@@ -381,7 +390,7 @@ let rec key_le ord k1 k2 = Arith.less_eq
 
 let rec key_lt ord k1 k2 = Arith.less_int (ord k1 k2) Arith.zero_int;;
 
-let rec kvs_equal x = Util.failwitha "FIXME patch" x;;
+let rec kvs_equal x y = (x=y)
 
 let rec check_keys
   cmp kl ks kr =
@@ -497,7 +506,7 @@ end;; (*struct Key_value*)
 
 module Tree : sig
   type ('a, 'b) tree = Node of ('a list * ('a, 'b) tree list) |
-    Leaf of ('a * 'b) list
+    Leaf of ('a * 'b) list [@@deriving yojson]
   val height : ('a, 'b) tree -> Arith.nat
   val dest_Node : ('a, 'b) tree -> 'a list * ('a, 'b) tree list
   val tree_equal : ('a, 'b) tree -> ('a, 'b) tree -> bool
@@ -511,7 +520,7 @@ module Tree : sig
 end = struct
 
 type ('a, 'b) tree = Node of ('a list * ('a, 'b) tree list) |
-  Leaf of ('a * 'b) list;;
+  Leaf of ('a * 'b) list  [@@deriving yojson];;
 
 let rec tree_to_subtrees
   t0 = (match t0
@@ -606,7 +615,7 @@ let rec dest_Node
   = function Node (ks, rs) -> (ks, rs)
     | Leaf uu -> Util.failwitha "dest_Node";;
 
-let rec tree_equal t1 t2 = Util.failwitha "FIXME patch";;
+let rec tree_equal t1 t2 = (t1=t2)
 
 let rec tree_to_leaves
   t0 = (match t0
@@ -681,7 +690,7 @@ end;; (*struct Tree*)
 
 module Tree_stack : sig
   type ('a, 'b, 'c) ts_frame_ext =
-    Ts_frame_ext of 'a list * 'b list * 'b * 'a list * 'b list * 'c
+    Ts_frame_ext of 'a list * 'b list * 'b * 'a list * 'b list * 'c [@@deriving yojson]
   val stack_map :
     ('a -> 'b) ->
       ('c, 'a, unit) ts_frame_ext list -> ('c, 'b, unit) ts_frame_ext list
@@ -710,7 +719,7 @@ module Tree_stack : sig
 end = struct
 
 type ('a, 'b, 'c) ts_frame_ext =
-  Ts_frame_ext of 'a list * 'b list * 'b * 'a list * 'b list * 'c;;
+  Ts_frame_ext of 'a list * 'b list * 'b * 'a list * 'b list * 'c [@@deriving yojson];;
 
 let rec f_t_update
   f_ta (Ts_frame_ext (f_ks1, f_ts1, f_t, f_ks2, f_ts2, more)) =
@@ -743,7 +752,7 @@ let rec no_focus
 
 let rec r_stk_to_rs xs = Util.rev_apply xs (List.map f_t);;
 
-let rec stack_equal s1 s2 = Util.failwitha "FIXME patch";;
+let rec stack_equal s1 s2 = (s1=s2)
 
 let rec dest_ts_frame
   f = ((Util.rev_apply f f_ks1, Util.rev_apply f f_ts1),
@@ -793,13 +802,13 @@ end;; (*struct Tree_stack*)
 
 module Frame : sig
   type ('a, 'b, 'c) frame = Node_frame of ('a list * 'c list) |
-    Leaf_frame of ('a * 'b) list
+    Leaf_frame of ('a * 'b) list  [@@deriving yojson]
   val dest_Leaf_frame : ('a, 'b, 'c) frame -> ('a * 'b) list
   val dest_Node_frame : ('a, 'b, 'c) frame -> 'a list * 'c list
 end = struct
 
 type ('a, 'b, 'c) frame = Node_frame of ('a list * 'c list) |
-  Leaf_frame of ('a * 'b) list;;
+  Leaf_frame of ('a * 'b) list  [@@deriving yojson];;
 
 let rec dest_Leaf_frame
   f = (match f with Node_frame _ -> Util.failwitha "dest_Leaf_frame"
@@ -947,7 +956,7 @@ let rec return x = (fun s -> (s, Util.Ok
 end;; (*struct Monad*)
 
 module Find : sig
-  type ('a, 'b, 'c) find_state
+  type ('a, 'b, 'c) find_state [@@deriving yojson]
   val find_step :
     ('a, 'b, 'c, 'd) Params.ps1 ->
       ('a, 'b, 'c) find_state -> 'd -> 'd * ('a, 'b, 'c) find_state Util.res
@@ -969,7 +978,7 @@ type ('a, 'b, 'c) find_state =
   F_down of ('c * ('a * ('c * ('a, 'c, unit) Tree_stack.ts_frame_ext list))) |
   F_finished of
     ('c * ('a * ('c * (('a * 'b) list *
-                        ('a, 'c, unit) Tree_stack.ts_frame_ext list))));;
+                        ('a, 'c, unit) Tree_stack.ts_frame_ext list)))) [@@deriving yojson];;
 
 let rec find_step
   ps1 fs =
@@ -1029,12 +1038,12 @@ end;; (*struct Find*)
 
 module Delete : sig
   type ('a, 'b, 'c) del_t = D_small_leaf of ('a * 'b) list |
-    D_small_node of ('a list * 'c list) | D_updated_subtree of 'c
+    D_small_node of ('a list * 'c list) | D_updated_subtree of 'c  [@@deriving yojson]
   type ('a, 'b, 'c) delete_state = D_down of (('a, 'b, 'c) Find.find_state * 'c)
     | D_up of
         (('a, 'b, 'c) del_t *
           (('a, 'c, unit) Tree_stack.ts_frame_ext list * 'c))
-    | D_finished of 'c
+    | D_finished of 'c  [@@deriving yojson]
   val delete_step :
     ('a, 'b, 'c, 'd) Params.ps1 ->
       ('a, 'b, 'c) delete_state -> 'd -> 'd * ('a, 'b, 'c) delete_state Util.res
@@ -1046,15 +1055,15 @@ module Delete : sig
         ('a, 'd) Tree.tree -> 'b -> 'a -> ('a, 'd, 'c) delete_state -> bool
 end = struct
 
-type ('a, 'b) d12_t = D1 of 'b | D2 of ('b * ('a * 'b));;
+type ('a, 'b) d12_t = D1 of 'b | D2 of ('b * ('a * 'b))  [@@deriving yojson];;
 
 type ('a, 'b, 'c) del_t = D_small_leaf of ('a * 'b) list |
-  D_small_node of ('a list * 'c list) | D_updated_subtree of 'c;;
+  D_small_node of ('a list * 'c list) | D_updated_subtree of 'c  [@@deriving yojson];;
 
 type ('a, 'b, 'c) delete_state = D_down of (('a, 'b, 'c) Find.find_state * 'c) |
   D_up of
     (('a, 'b, 'c) del_t * (('a, 'c, unit) Tree_stack.ts_frame_ext list * 'c))
-  | D_finished of 'c;;
+  | D_finished of 'c  [@@deriving yojson];;
 
 let rec wf_d
   k_ord r2f t0 s d =
@@ -1481,10 +1490,10 @@ let rec wellformed_delete_state
 end;; (*struct Delete*)
 
 module Insert : sig
-  type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c))
+  type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c)) [@@deriving yojson]
   type ('a, 'b, 'c) insert_state = I_down of (('a, 'b, 'c) Find.find_state * 'b)
     | I_up of (('a, 'b, 'c) i12_t * ('a, 'c, unit) Tree_stack.ts_frame_ext list)
-    | I_finished of 'c
+    | I_finished of 'c  [@@deriving yojson]
   val insert_step :
     ('a, 'b, 'c, 'd) Params.ps1 ->
       ('a, 'b, 'c) insert_state -> 'd -> 'd * ('a, 'b, 'c) insert_state Util.res
@@ -1497,11 +1506,11 @@ module Insert : sig
           'b -> 'a -> 'd -> ('a, 'd, 'c) insert_state -> bool
 end = struct
 
-type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c));;
+type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c)) [@@deriving yojson];;
 
 type ('a, 'b, 'c) insert_state = I_down of (('a, 'b, 'c) Find.find_state * 'b) |
   I_up of (('a, 'b, 'c) i12_t * ('a, 'c, unit) Tree_stack.ts_frame_ext list) |
-  I_finished of 'c;;
+  I_finished of 'c  [@@deriving yojson];;
 
 let rec wf_d
   k_ord r2t t0 s d =
