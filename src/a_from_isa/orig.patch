--- orig.ml	2017-04-30 11:05:00.330798222 +0100
+++ patched.ml	2017-04-30 11:05:46.955310361 +0100
@@ -278,9 +278,14 @@ let rec is_none = function Some x -> fal
 
 end;; (*struct Option*)
 
+module Res = struct
+  include Pervasives
+  type 'a res = ('a,string) result
+end
+
 module Util : sig
+  include module type of Res
   type error = String_error of string
-  type 'a res = Ok of 'a | Error of error
   val rev_apply : 'a -> ('a -> 'b) -> 'b
   val unzip : ('a * 'b) list -> 'a list * 'b list
   val from_to : Arith.nat -> Arith.nat -> Arith.nat list
@@ -299,7 +304,7 @@ end = struct
 
 type error = String_error of string;;
 
-type 'a res = Ok of 'a | Error of error;;
+include Res
 
 let rec rev_apply x f = f x;;
 
@@ -311,7 +316,7 @@ let rec from_to x y = List.upt x (Arith.
 
 let rec is_None x = Option.is_none x;;
 
-let rec failwitha x = rev_apply "FIXME patch" (fun _ -> failwith "undefined");;
+let rec failwitha x = failwith x
 
 let rec split_at n xs = (List.take n xs, List.drop n xs);;
 
@@ -372,7 +377,7 @@ let rec key_le ord k1 k2 = Arith.less_eq
 
 let rec key_lt ord k1 k2 = Arith.less_int (ord k1 k2) Arith.zero_int;;
 
-let rec kvs_equal x = Util.failwitha "FIXME patch" x;;
+let rec kvs_equal x y = (x=y)
 
 let rec check_keys
   cmp kl ks kr =
@@ -576,7 +581,7 @@ let rec dest_Node
   = function Node (ks, rs) -> (ks, rs)
     | Leaf uu -> Util.failwitha "dest_Node";;
 
-let rec tree_equal t1 t2 = Util.failwitha "FIXME patch";;
+let rec tree_equal t1 t2 = (t1=t2)
 
 let rec tree_to_leaves
   t0 = (match t0
@@ -713,7 +718,7 @@ let rec no_focus
 
 let rec r_stk_to_rs xs = Util.rev_apply xs (List.map f_t);;
 
-let rec stack_equal s1 s2 = Util.failwitha "FIXME patch";;
+let rec stack_equal s1 s2 = (s1=s2)
 
 let rec dest_ts_frame
   f = ((Util.rev_apply f f_ks1, Util.rev_apply f f_ts1),
