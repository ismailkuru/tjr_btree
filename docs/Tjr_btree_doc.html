<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Exhaustive_in_mem.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Isa_test" rel="Chapter" href="Isa_test.html">
<link title="Test" rel="Chapter" href="Test.html">
<link title="Profile" rel="Chapter" href="Profile.html">
<link title="Base_types_pervasives" rel="Chapter" href="Base_types_pervasives.html">
<link title="Block" rel="Chapter" href="Block.html">
<link title="Frame" rel="Chapter" href="Frame.html">
<link title="Ls_state" rel="Chapter" href="Ls_state.html">
<link title="Ord" rel="Chapter" href="Ord.html">
<link title="R2f" rel="Chapter" href="R2f.html">
<link title="Rstk" rel="Chapter" href="Rstk.html">
<link title="String_" rel="Chapter" href="String_.html">
<link title="Tree" rel="Chapter" href="Tree.html">
<link title="R2t" rel="Chapter" href="R2t.html">
<link title="Params" rel="Chapter" href="Params.html">
<link title="Base_types" rel="Chapter" href="Base_types.html">
<link title="Disk_ops" rel="Chapter" href="Disk_ops.html">
<link title="Leaf_stream_ops" rel="Chapter" href="Leaf_stream_ops.html">
<link title="Leaf_stream_util" rel="Chapter" href="Leaf_stream_util.html">
<link title="Map_ops" rel="Chapter" href="Map_ops.html">
<link title="Page_ref_int" rel="Chapter" href="Page_ref_int.html">
<link title="Pre_map_ops" rel="Chapter" href="Pre_map_ops.html">
<link title="Store_ops" rel="Chapter" href="Store_ops.html">
<link title="Iter_leaf_stream" rel="Chapter" href="Iter_leaf_stream.html">
<link title="Big_step" rel="Chapter" href="Big_step.html">
<link title="Store_to_map" rel="Chapter" href="Store_to_map.html">
<link title="Disk_on_fd" rel="Chapter" href="Disk_on_fd.html">
<link title="Disk_to_store" rel="Chapter" href="Disk_to_store.html">
<link title="Mem_store" rel="Chapter" href="Mem_store.html">
<link title="Recycling_store" rel="Chapter" href="Recycling_store.html">
<link title="Binprot_marshalling" rel="Chapter" href="Binprot_marshalling.html">
<link title="Bytestore" rel="Chapter" href="Bytestore.html">
<link title="Digest_" rel="Chapter" href="Digest_.html">
<link title="Map_int_blk" rel="Chapter" href="Map_int_blk.html">
<link title="Map_int_blkx" rel="Chapter" href="Map_int_blkx.html">
<link title="Map_on_fd" rel="Chapter" href="Map_on_fd.html">
<link title="Mem_map" rel="Chapter" href="Mem_map.html">
<link title="Small_string" rel="Chapter" href="Small_string.html">
<link title="Examples_common" rel="Chapter" href="Examples_common.html">
<link title="Bin_prot_util" rel="Chapter" href="Bin_prot_util.html">
<link title="Map_int_int" rel="Chapter" href="Map_int_int.html">
<link title="Ss_int_map_on_fd" rel="Chapter" href="Ss_int_map_on_fd.html">
<link title="Ss_ss_map_on_fd" rel="Chapter" href="Ss_ss_map_on_fd.html">
<link title="Default_filename" rel="Chapter" href="Default_filename.html">
<link title="Insert_delete_ops" rel="Chapter" href="Insert_delete_ops.html">
<link title="Range" rel="Chapter" href="Range.html">
<link title="Test_bytestore" rel="Chapter" href="Test_bytestore.html">
<link title="Test_common" rel="Chapter" href="Test_common.html">
<link title="Test_int_int_on_fd" rel="Chapter" href="Test_int_int_on_fd.html">
<link title="Test_mem_map" rel="Chapter" href="Test_mem_map.html">
<link title="Test_string_int_on_fd" rel="Chapter" href="Test_string_int_on_fd.html">
<link title="Tree_store" rel="Chapter" href="Tree_store.html">
<link title="Exhaustive_in_mem" rel="Chapter" href="Exhaustive_in_mem.html">
<link title="Tjr_btree_doc" rel="Chapter" href="Tjr_btree_doc.html"><link title="Introduction" rel="Section" href="#1_Introduction">
<link title="Ancestor projects" rel="Section" href="#1_Ancestorprojects">
<link title="Directory structure" rel="Section" href="#1_Directorystructure">
<link title="Naming conventions" rel="Section" href="#1_Namingconventions">
<link title="Monads!" rel="Section" href="#1_Monads">
<link title="Exported code from Isabelle" rel="Section" href="#1_ExportedcodefromIsabelle">
<link title="Test" rel="Section" href="#1_Test">
<link title="Base types" rel="Section" href="#1_Basetypes">
<link title="Api" rel="Section" href="#1_Api">
<link title="Store to map" rel="Section" href="#1_Storetomap">
<link title="Disks" rel="Section" href="#1_Disks">
<link title="Stores" rel="Section" href="#1_Stores">
<link title="Binprot marshalling" rel="Section" href="#1_Binprotmarshalling">
<link title="Cache" rel="Section" href="#1_Cache">
<link title="Examples" rel="Section" href="#1_Examples">
<link title="Testing" rel="Section" href="#1_Testing">
<link title="Doc" rel="Section" href="#1_Doc">
<title>Tjr_btree_doc</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Exhaustive_in_mem.html" title="Exhaustive_in_mem">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Tjr_btree_doc.html">Tjr_btree_doc</a></h1>

<pre><span id="MODULETjr_btree_doc"><span class="keyword">module</span> Tjr_btree_doc</span>: <code class="code">sig</code> <a href="Tjr_btree_doc.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<p>Main documentation entry point.</p>
</div>
</div>
<hr width="100%">
<p>This file contains general documentation and an overview of the
code. Follow the links to individual modules for more information.</p>

<h2 id="1_Introduction">Introduction</h2>
<p>This library implements a B-tree in OCaml. The source is actually
exported from Isabelle, and then OCaml code wraps the
Isabelle-generated code. This is the documentation for the OCaml
wrapper. The documentation for the core B-tree routines can be found
in the <code class="code">isa_btree</code> repository.</p>

<p>This document gives an overview of the (sub)packages and a guide to
the structure of the code. Detailed
comments are included in the individual modules.</p>

<h2 id="1_Ancestorprojects">Ancestor projects</h2>
<p>See the <code class="code">README.org</code> in the project root directory for a list of
dependencies.</p>

<h2 id="1_Directorystructure">Directory structure</h2>
<p>The code is organized into subdirectories (subpackages), and the
subdirectories are in a linear order (which corresponds to the
dependencies between modules). For example, the first subdirectory
(ignoring <code class="code">aa_from_isa</code> since it is not used) is <code class="code">ac_test</code> which is
discussed in the section "Test" below.</p>

<h2 id="1_Namingconventions">Naming conventions</h2>
<p>To understand the interfaces, we need to introduce the following:</p>

<ul>
<li>Keys, represented by type variable <code class="code">'k</code> </li>
<li>Values, type var <code class="code">'v</code> </li>
<li>Page/block references, <code class="code">'r</code> </li>
<li>Global state, <code class="code">'t</code></li>
</ul>
<h2 id="1_Monads">Monads!</h2>
<p>The entire development is parameterized by some notion of
monad. Before reading the rest of the documentation, please look at
the module <code class="code">Tjr_monad</code> from ancestor project <code class="code">tjr_monad</code>. Essentially
we use a type <code class="code">('a,'t) m</code>, where <code class="code">'t</code> is some phantom type var that is
used to identify a particular monad instance. There is an associated
type <code class="code">'t monad_ops</code> which provides the expected return and bind. In
order to get parametricity over the monad, we are forced to pass
<code class="code">monad_ops</code> as parameters to many functions.</p>

<h2 id="1_ExportedcodefromIsabelle">Exported code from Isabelle</h2>
<p>Exported code is in the <code class="code">isa_btree</code> opam/ocamlfind package. The
<code class="code">from_isa</code> package here is not used. FIXME</p>

<h2 id="1_Test">Test</h2>
<p>Some simple testing utility functions.</p>

<h2 id="1_Basetypes">Base types</h2>
<p>This package contains basic B-tree related types:</p>

<ul>
<li><a href="Base_types.html"><code class="code">Base_types</code></a> includes most of the other modules in this package</li>
<li><a href="Base_types_pervasives.html"><code class="code">Base_types_pervasives</code></a> which includes utility functions assumed by
  the other modules</li>
<li><a href="Block.html"><code class="code">Block</code></a> for blocks on disk</li>
<li><code class="code">Constants</code> which give size constraints on B-tree nodes FIXME now
  in isa_btree</li>
<li><a href="Frame.html"><code class="code">Frame</code></a> which imports the Isabelle frame type</li>
<li><a href="Ls_state.html"><code class="code">Ls_state</code></a> for the leaf stream state</li>
<li><a href="Ord.html"><code class="code">Ord</code></a> for orderings (typically over keys)</li>
<li><a href="Params.html"><code class="code">Params</code></a> for various projection functions from a "parameters" object</li>
<li><a href="R2f.html"><code class="code">R2f</code></a> and <a href="R2t.html"><code class="code">R2t</code></a> for internal types used in testing (convert a
  block ref to a frame/tree)</li>
<li><a href="Rstk.html"><code class="code">Rstk</code></a> for the type of framestacks</li>
<li><a href="String_.html"><code class="code">String_</code></a> for various string utility functions</li>
<li><a href="Tree.html"><code class="code">Tree</code></a> for the tree type imported from Isabelle</li>
</ul>
<p>The <a href="Tree.html"><code class="code">Tree</code></a> module describes a B-tree as an algebraic datatype. The
on-disk B-tree uses references between blocks i.e. a graph-like
structure with pointers rather than a datatype. Indeed, the tree
datatype is used only for testing purposes.</p>

<h2 id="1_Api">Api</h2>
<p>This package gives the main interface types, including interfaces for
disk, store and map.</p>

<ul>
<li><a href="Disk_ops.html"><code class="code">Disk_ops</code></a> for the low-level block interface</li>
<li><a href="Leaf_stream_ops.html"><code class="code">Leaf_stream_ops</code></a> and <a href="Leaf_stream_util.html"><code class="code">Leaf_stream_util</code></a> for leaf streams</li>
<li><a href="Map_ops.html"><code class="code">Map_ops</code></a> for map operations, find etc.</li>
<li><a href="Page_ref_int.html"><code class="code">Page_ref_int</code></a> utility module to fix page ref as an integer</li>
<li><a href="Pre_map_ops.html"><code class="code">Pre_map_ops</code></a> like <a href="Map_ops.html"><code class="code">Map_ops</code></a> but with explicit state passing</li>
<li><a href="Store_ops.html"><code class="code">Store_ops</code></a> for a layer just above <a href="Disk_ops.html"><code class="code">Disk_ops</code></a></li>
</ul>
<p>In addition, the leaf stream interface allows to iterate over the
leaves in a B-tree e.g. to find all the bindings in the map. This
module also documents the type variable naming conventions (see
<a href="Map_ops.html"><code class="code">Map_ops</code></a>).</p>

<p><b>Important note on code style:</b> Interfaces are essentially groups of
polymorphic functions, collected together and named using a record
type. For example, map operations are something of the form
<code class="code">('k,'v,'t) map_ops</code>. To get a handle on the components of such a
thing we provide functions such as <a href="Map_ops.html#VALdest_map_ops"><code class="code">Map_ops.dest_map_ops</code></a> which takes
a set of map operations and a "continuation" function and calls the
function with the components of the record. Example code should make
this clearer:</p>

<pre class="verbatim">dest_imperative_map_ops map_ops @@ fun ~find ~insert ~delete -&gt;
  (* write values *)
  for x=1 to max do
    insert (k x) (v x);
  done;</pre>
<h2 id="1_Storetomap">Store to map</h2>
<p>This package, particularly the <a href="Store_to_map.html"><code class="code">Store_to_map</code></a> module, wraps the
Isabelle routines to implement a map interface on top of a
store. The key function is <a href="Store_to_map.html#VALstore_ops_to_map_ops"><code class="code">Store_to_map.store_ops_to_map_ops</code></a>
which takes a <code class="code">store_ops</code> and returns a <code class="code">map_ops</code>.</p>

<p>Also included here are <a href="Big_step.html"><code class="code">Big_step</code></a> (to iterate the small step
operations provided by Isabelle) and <a href="Iter_leaf_stream.html"><code class="code">Iter_leaf_stream</code></a> (to wrap
small-step leaf stream operations).</p>

<h2 id="1_Disks">Disks</h2>
<p><a href="Disk_on_fd.html"><code class="code">Disk_on_fd</code></a> is a persistent block device on top of a "normal" file.</p>

<p><a href="Disk_to_store.html"><code class="code">Disk_to_store</code></a> includes a function that naively transforms a disk
to a store.</p>

<h2 id="1_Stores">Stores</h2>
<p><a href="Mem_store.html"><code class="code">Mem_store</code></a> is an in-memory store.</p>

<p><a href="Recycling_store.html"><code class="code">Recycling_store</code></a> is a store that optimizes page alloc and free to
avoid too many unnecessary writes. Currently commented out. FIXME?</p>

<h2 id="1_Binprotmarshalling">Binprot marshalling</h2>
<p><a href="Binprot_marshalling.html"><code class="code">Binprot_marshalling</code></a> provides on-disk marshalling courtesy of
<code class="code">binprot</code>. You can, of course, provide your own marshalling code,
which may be useful if your backend doesn't support binprot (js_of_ocaml?)</p>

<h2 id="1_Cache">Cache</h2>
<p>A generic LRU <code class="code">Cache</code> on top of a map. This is rather more
sophisticated than usual because we have to do various things when
cache entries (eg uncommitted disk operations) are flushed.</p>

<h2 id="1_Examples">Examples</h2>
<p>Various examples.</p>

<p><a href="Bin_prot_util.html"><code class="code">Bin_prot_util</code></a> is a very small module which defines eg
<code class="code">bp_size_int</code>.</p>

<p><a href="Bytestore.html"><code class="code">Bytestore</code></a> provides a mechanism to store arbitrary length byte
buffers on top of a store. Currently commented out. FIXME?</p>

<p><a href="Digest_.html"><code class="code">Digest_</code></a> provides a digest/hash of a string, for situations where a
string is used as a key, but the exact contents of the string is not needed.</p>

<p><a href="Examples_common.html"><code class="code">Examples_common</code></a></p>

<p><a href="Map_int_blk.html"><code class="code">Map_int_blk</code></a> provides a map from blk index to blk</p>

<p><a href="Map_int_blkx.html"><code class="code">Map_int_blkx</code></a> provides a map from blk index to (partial) blk (i.e.,
only the first part of the blk is used).</p>

<p><a href="Map_int_int.html"><code class="code">Map_int_int</code></a> provides a map from int to int, using <code class="code">binprot</code>
marshalling.</p>

<p><a href="Map_on_fd.html"><code class="code">Map_on_fd</code></a> is a generic map backed by a file descriptor.</p>

<p><a href="Mem_map.html"><code class="code">Mem_map</code></a> is a generic map on top of the <a href="Mem_store.html"><code class="code">Mem_store</code></a>.</p>

<p><a href="Small_string.html"><code class="code">Small_string</code></a> provides a string with a max size of 256 bytes
(using arbitrary length strings as keys requires another approach).</p>

<p><a href="Ss_ss_map_on_fd.html"><code class="code">Ss_ss_map_on_fd</code></a> implements an on-disk map from small string to
small string.</p>

<h2 id="1_Testing">Testing</h2>
<p>Various modules to support testing. Some of this looks a bit
suspicious. FIXME</p>

<h2 id="1_Doc">Doc</h2>
<p>Contains this overview documentation in module <a href="Tjr_btree_doc.html"><code class="code">Tjr_btree_doc</code></a>.</p>

<pre><span id="VALdummy"><span class="keyword">val</span> dummy</span> : <code class="type">int</code></pre></body></html>